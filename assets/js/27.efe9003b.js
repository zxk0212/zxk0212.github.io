(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{398:function(v,_,t){"use strict";t.r(_);var a=t(42),s=Object(a.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h2",{attrs:{id:"设计模式常用七大原则"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#设计模式常用七大原则"}},[v._v("#")]),v._v(" 设计模式常用七大原则")]),v._v(" "),t("ol",[t("li",[v._v("单一职责原则")]),v._v(" "),t("li",[v._v("接口隔离原则")]),v._v(" "),t("li",[v._v("依赖倒转原则")]),v._v(" "),t("li",[v._v("里氏替换原则")]),v._v(" "),t("li",[v._v("开闭原则")]),v._v(" "),t("li",[v._v("迪米特法则")]),v._v(" "),t("li",[v._v("合成复用原则")])]),v._v(" "),t("h2",{attrs:{id:"单一职责原则"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#单一职责原则"}},[v._v("#")]),v._v(" 单一职责原则")]),v._v(" "),t("blockquote",[t("p",[v._v("​\t对类来说，一个类应该只负责一项职责。")])]),v._v(" "),t("h4",{attrs:{id:"单一职责原则注意事项和细节"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#单一职责原则注意事项和细节"}},[v._v("#")]),v._v(" "),t("strong",[v._v("单一职责原则注意事项和细节")])]),v._v(" "),t("ol",[t("li",[v._v("降低类的复杂度，一个类只负责一项职责。")]),v._v(" "),t("li",[v._v("提高类的可读性，可维护性")]),v._v(" "),t("li",[v._v("降低变更引起的风险")]),v._v(" "),t("li",[v._v("通常情况下，我们应当遵守单一职责原则，只有逻辑足够简单，才可以违背单一职责原则")])]),v._v(" "),t("h2",{attrs:{id:"接口隔离原则"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#接口隔离原则"}},[v._v("#")]),v._v(" 接口隔离原则")]),v._v(" "),t("blockquote",[t("p",[v._v("​\t客户端不应该依赖他不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上。")])]),v._v(" "),t("h2",{attrs:{id:"依赖倒转原则"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#依赖倒转原则"}},[v._v("#")]),v._v(" 依赖倒转原则")]),v._v(" "),t("blockquote",[t("ol",[t("li",[v._v("高层模块不应该依赖低层模块，二者都应该依赖其抽象")]),v._v(" "),t("li",[t("strong",[v._v("抽象不应该依赖细节，细节应该依赖抽象")])]),v._v(" "),t("li",[v._v("依赖倒转的中心思想是面向"),t("strong",[v._v("接口编程")])])])]),v._v(" "),t("p",[v._v("设计理念： 相对于细节的多变性，抽象的东西要稳定的多，以抽象为基础搭建的架构比以细节为基础的架构要稳定的多。java中，抽象指的是接口和抽象类，细节就是具体的实现类。")]),v._v(" "),t("p",[v._v("使用接口的抽象类的目的主要是制定好规范，而不涉及任何具体的操作，把展现细节的任务交给具体类去实现。")]),v._v(" "),t("h4",{attrs:{id:"依赖关系传递的三种方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#依赖关系传递的三种方法"}},[v._v("#")]),v._v(" 依赖关系传递的三种方法")]),v._v(" "),t("ol",[t("li",[v._v("接口传递")]),v._v(" "),t("li",[v._v("构造方法传递")]),v._v(" "),t("li",[v._v("setter方式传递")])]),v._v(" "),t("h4",{attrs:{id:"注意事项"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#注意事项"}},[v._v("#")]),v._v(" "),t("strong",[v._v("注意事项")]),v._v("：")]),v._v(" "),t("ol",[t("li",[v._v("低层模块尽量都要有抽象类或接口，这样程序稳定性更好")]),v._v(" "),t("li",[v._v("变量声明尽量是抽象类或接口，这样我们变量引用和实际对象之间，就存在了一个缓冲层，利于程序扩展和优化")]),v._v(" "),t("li",[v._v("继承时遵守里氏替换原则")])]),v._v(" "),t("h2",{attrs:{id:"里氏替换原则"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#里氏替换原则"}},[v._v("#")]),v._v(" 里氏替换原则")]),v._v(" "),t("h4",{attrs:{id:"继承的思考"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#继承的思考"}},[v._v("#")]),v._v(" "),t("strong",[v._v("继承的思考")])]),v._v(" "),t("p",[v._v("继承在给程序设计带来便利的同时，也带来了弊端，比如使用继承会给程序带来侵入性，程序的可移植性降低，增加对象间的耦合性，如果一个类被其他的类所继承，则当这个类需要修改的时候，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能产生故障。")]),v._v(" "),t("p",[v._v("如何正确的使用继承 => 里氏替换原则")]),v._v(" "),t("blockquote",[t("p",[v._v("引用基类的地方必须能透明的使用其子类的对象")]),v._v(" "),t("p",[v._v("在继承时，遵循里氏替换原则，在子类中尽量不要重写父类的方法")]),v._v(" "),t("p",[v._v("继承关系，在适当情况下，可以通过聚合，组合，依赖来解决")])]),v._v(" "),t("h2",{attrs:{id:"开闭原则"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#开闭原则"}},[v._v("#")]),v._v(" 开闭原则")]),v._v(" "),t("blockquote",[t("p",[v._v("开闭原则是编程中最基础，最重要的设计原则")]),v._v(" "),t("p",[v._v("一个软件实体（类，模块和函数），应该对扩展开放（对提供方），对修改关闭（对使用方）。用抽象构建框架，用实现扩展细节")]),v._v(" "),t("p",[v._v("当软件需要发生变化时，尽量通过扩展软件的实体行为来实现变化，而不是通过修改已有代码来实现变化")]),v._v(" "),t("p",[v._v("编程中遵循其他原则和使用设计模式的目的就是遵循开闭原则")])]),v._v(" "),t("h2",{attrs:{id:"迪米特法则"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#迪米特法则"}},[v._v("#")]),v._v(" 迪米特法则")]),v._v(" "),t("blockquote",[t("ol",[t("li",[v._v("一个对象应该对其他对象保持最少的了解")]),v._v(" "),t("li",[v._v("类与类关系越密切，耦合度就越大")]),v._v(" "),t("li",[v._v("对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外除了提供public方法，不对外泄露任何信息")]),v._v(" "),t("li",[v._v("迪米特法则也可以描述为：只与直接朋友通信")])])]),v._v(" "),t("h3",{attrs:{id:"迪米特法则的注意事项和细节"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#迪米特法则的注意事项和细节"}},[v._v("#")]),v._v(" 迪米特法则的注意事项和细节")]),v._v(" "),t("ol",[t("li",[v._v("迪米特法则的核心是降低类之间的耦合")]),v._v(" "),t("li",[v._v("迪米特法则只是降低类之间耦合关系，并不是要求完全没有依赖关系")])]),v._v(" "),t("h2",{attrs:{id:"合成复用原则"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#合成复用原则"}},[v._v("#")]),v._v(" 合成复用原则")]),v._v(" "),t("blockquote",[t("p",[v._v("​\t尽量使用合成/聚合的方式，而不是使用继承")])])])}),[],!1,null,null,null);_.default=s.exports}}]);